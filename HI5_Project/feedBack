호텔 예약 프로그램

전체적으로 대부분의 클래스의 멤버 변수가 default 접근 지정자로 선언되어 있는데, 상속 관계를 제외하고는 대부분 private로 선언하는 것이 일반적입니다. 
(상속 관계에서 부모 클래스의 멤버 변수를 자식 클래스에서 다이렉트로 접근하고 싶을 때는 protected까지는 허용함.)

Mail 클래스에서 메서드의 접근 지정자는 매우 지정해주셨습니다. (외부 호출이 필요한 메서드 - public, 내부 메서드에서 호출하는 메서드 - private)
BookProgram의 멤버 변수 초기화 같은 코드는 생성자에서 하는 것이 바람직합니다. mail 메서드에서 new BookProgram(); 과 같은 디폴트 생성자를 사용하므로, 
해당 생성자 내부에 this.guest = new Guest(); 등의 코드를 두는 것이 훨씬 더 바람직함.

전체: Booking 클래스 구조가 좀 아쉽습니다. 기본적으로 OOP 다운 코드를 짜려고 하면, 정보만을 갖는 클래스와 비즈니스 로직만을 갖는 클래스가 구분되어야 합니다. 
짜놓으신 코드에서는 정보를 의미하는 멤버 변수 (Guest, Room, date, Hotel 등)와 비즈니스 로직을 위해 사용하는 멤버 변수 (Scanner, mapRoom, mapBooking, bookingList)가 섞여 있는 구조입니다. 
Booking에서는 정보를 갖는 멤버 변수를 가지고 적절히 setter/getter 등을 이용하여 정보를 제공하는 것만 존재해야 하고, 실제 비즈니스 로직은 BookProgram에 존재해야 합니다. 
(스프링에서 Service에서 해당하는 클래스는 비즈니스 로직을 수행하고, 특정 정보를 특정 객체에 담아 Controller에 보내주는 구조로 되어 있고, Entity 혹은 DTO 같은 객체는 말 그대로 정보만을 담습니다.)


박행복님: 하나의 메서드에는 웬만하면 하나의 return만 있는게 좋은 코드입니다. 
나중에 실무에서 PMD 같은 정적 도구 같은 것을 적용해보시면 하나의 메서드에 return 구문이 여러 개 있으면 해당 예외를 뱉어내, 
코드 리팩토링 대상이 되니 참고 하시면 좋을 것 같습니다. PMC.OnlyOneReturn 그 외의 적절한 분기 처리로 잘 처리해주신 것 같습니다.


메모 프로그램:
호텔 예약 프로그램과 똑같은 코멘트를 달겠습니다. 멤버 변수의 접근 지정자와, 정보를 담는 클래스와 비즈니스 로직를 담는 클래스를 분리해주세요.

또,, 해당 프로그램은 굉장히 아쉬운 점은 OOP를 적용하기 아주 알맞은 구조였는데, 이 점을 살리지 못했다는 점입니다. 
코드를 세세하게 본  건 아니지만, Amend, Delete 등의 연산을 담당하는 클래스들의 실제 비즈니스 로직은 다르지만, 
"비밀번호를 검증하고 이게 맞으면 연산 수행"이라는 목적은 모두 동일해보이는데, 이런 코드를 Operation 같은 상위 클래스를 두고 상속 구조를 만드셨으면 정말 100점짜리 코드였는데 이 부분이 많이 아쉽습니다.
